# Архитектура AggreGate SDK

## Обзор

AggreGate SDK представляет собой набор библиотек и инструментов для разработки приложений на платформе AggreGate. SDK построен на модульной архитектуре, что обеспечивает гибкость и расширяемость.

## Модульная структура

### Основные модули

```
aggregate-sdk/
├── aggregate-api/          # Основная API библиотека
├── widget-api/             # API для виджетов
├── demo-agent/             # Пример агента
├── demo-api/               # Примеры использования API
├── demo-driver/            # Пример драйвера устройства
├── demo-plugin/            # Пример серверного плагина
└── context-demo-web-app/   # Пример веб-приложения
```

### aggregate-api

**Назначение:** Основная библиотека, предоставляющая API для работы с AggreGate сервером.

**Основные пакеты:**
- `com.tibbo.aggregate.common.agent` - API для создания агентов
- `com.tibbo.aggregate.common.context` - Работа с контекстами
- `com.tibbo.aggregate.common.datatable` - Структуры данных
- `com.tibbo.aggregate.common.device` - API для драйверов устройств
- `com.tibbo.aggregate.common.protocol` - Протокол связи с сервером
- `com.tibbo.aggregate.common.plugin` - API для серверных плагинов

**Ключевые классы:**
- `Agent` - базовый класс для агентов
- `AgentContext` - контекст агента
- `RemoteServerController` - управление удаленным сервером
- `Context` - базовый интерфейс контекста
- `DataTable` - табличная структура данных

### widget-api

**Назначение:** API для создания пользовательских виджетов.

**Основные компоненты:**
- Рендеринг виджетов
- Обработка событий
- Интеграция с контекстами

## Архитектурные паттерны

### 1. Модульность

Проект разделен на логические модули, каждый из которых имеет четко определенную ответственность:
- **API модули** - предоставляют функциональность
- **Demo модули** - демонстрируют использование API

### 2. Dependency Injection

Использование dependency injection через конструкторы и методы установки:
```java
Agent agent = new Agent(agentContext, false, false, 0);
```

### 3. Builder Pattern

Использование builder-подобных паттернов для создания сложных объектов:
```java
TableFormat format = new TableFormat(1, 100);
format.addField("<field><S><D=Description>");
```

### 4. Observer Pattern

События и слушатели для асинхронной обработки:
```java
context.addEventListener("event", new DefaultContextEventListener() {
    @Override
    public void handle(Event event) {
        // Обработка события
    }
});
```

### 5. Factory Pattern

Создание объектов через фабричные методы:
```java
FieldFormat ff = FieldFormat.create("fieldName", FieldFormat.STRING_FIELD);
```

## Потоки данных

### Агент → Сервер

```
Agent → AgentContext → Protocol → RemoteServer → AggreGate Server
```

1. Агент создает события/изменения переменных
2. `AgentContext` обрабатывает и форматирует данные
3. Протокол сериализует данные
4. `RemoteServer` отправляет данные на сервер

### Сервер → Агент

```
AggreGate Server → RemoteServer → Protocol → AgentContext → Agent
```

1. Сервер отправляет команды
2. Протокол десериализует данные
3. `AgentContext` обрабатывает команды
4. Агент выполняет действия

## Управление зависимостями

### Централизованное управление

Все версии зависимостей управляются через `buildSrc/src/main/java/Dependencies.kt`:

```kotlin
object Log4JLibs {
    object Versions {
        const val log4jVersion = "2.23.1"
    }
    const val log4jApi = "org.apache.logging.log4j:log4j-api:${Versions.log4jVersion}"
}
```

### Основные зависимости

- **Logging:** Log4j 2.23.1, SLF4J 2.0.9
- **Collections:** Guava 32.1.3
- **Testing:** JUnit 5.10.1, Mockito 5.8.0
- **Apache Commons:** Lang3, Math3, Codec, IO

## Обработка ошибок

### Иерархия исключений

```
AggreGateException (базовое)
├── ContextException
├── DeviceException
├── DisconnectionException
└── PluginException
```

### Стратегия обработки

1. **Логирование:** Все ошибки логируются через `Log`
2. **Проброс:** Исключения пробрасываются наверх для обработки
3. **Восстановление:** Агенты автоматически переподключаются при разрыве связи

## Безопасность

### Аутентификация

- Использование username/password для подключения
- Поддержка различных уровней доступа (admin, manager, observer)

### Безопасность типов

- Использование generics для типобезопасности
- Валидация данных на уровне API

## Производительность

### Оптимизации

1. **Кэширование:** Кэширование контекстов и переменных
2. **Асинхронность:** Асинхронная обработка событий
3. **Пул потоков:** Использование пула потоков для параллельной обработки

### Мониторинг

- Логирование производительности операций
- Метрики выполнения команд

## Расширяемость

### Точки расширения

1. **Агенты:** Наследование от `Agent` и `AgentContext`
2. **Драйверы:** Реализация `AbstractDeviceDriver`
3. **Плагины:** Наследование от `AbstractContextPlugin`
4. **Виджеты:** Использование Widget API

### Примеры расширения

См. модули `demo-*` для примеров реализации:
- `demo-agent` - пример агента
- `demo-driver` - пример драйвера
- `demo-plugin` - пример плагина

## Тестирование

### Стратегия тестирования

1. **Unit-тесты:** Тестирование отдельных компонентов
2. **Интеграционные тесты:** Тестирование взаимодействия компонентов
3. **Примеры:** Demo-модули служат как примеры использования

### Покрытие кода

- Использование JaCoCo для измерения покрытия
- Минимальное покрытие: 30%

## Сборка и развертывание

### Система сборки

- **Gradle 8.5** с Kotlin DSL
- Многомодульная сборка
- Автоматическое тестирование

### CI/CD

- GitHub Actions для автоматической сборки
- Тестирование на разных платформах
- Автоматическая публикация артефактов

## Будущие улучшения

### Планируемые изменения

1. Миграция на Java 11+ для использования современных возможностей
2. Улучшение покрытия тестами
3. Добавление интеграционных тестов
4. Оптимизация производительности
5. Расширение документации API

---

*Документ обновлен: 2024-12-XX*

