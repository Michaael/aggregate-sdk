# Как правильно создавать переменные в модели через Remote API

**Дата:** 12.12.2025  
**Версия SDK:** 1.3.6

## Обзор

Для создания переменных в контексте модели через Remote API нужно работать с переменной `V_MODEL_VARIABLES`, которая содержит список определений переменных модели. Это отличается от обычных контекстов, где используется переменная `V_VARIABLES`.

## Важные моменты

1. **ProxyContext не поддерживает `addVariableDefinition()` напрямую**
   - Метод `addVariableDefinition()` работает только для локальных контекстов
   - Для удаленных контекстов (ProxyContext) нужно работать через переменные

2. **Для модели используется `V_MODEL_VARIABLES`**
   - Стандартная переменная `V_VARIABLES` может быть недоступна для контекста модели
   - SDK автоматически переключается на `V_MODEL_VARIABLES` при необходимости

3. **Два способа создания переменных:**
   - **Способ 1:** Работа с переменной `V_MODEL_VARIABLES` напрямую
   - **Способ 2:** Использование функции `updateVariable` (если доступна)

## Способ 1: Работа с переменной V_MODEL_VARIABLES

### Шаг 1: Получение контекста модели

```java
RemoteServer server = new RemoteServer("localhost", 6460, "admin", "admin");
RemoteServerController controller = new RemoteServerController(server, true);
controller.connect();
controller.login();

ContextManager cm = controller.getContextManager();
Context modelContext = cm.get("users.admin.models.myModel");
```

### Шаг 2: Получение текущих определений переменных

```java
import com.tibbo.aggregate.common.server.ModelContextConstants;
import com.tibbo.aggregate.common.context.VariableDefinition;
import com.tibbo.aggregate.common.datatable.DataTable;
import com.tibbo.aggregate.common.datatable.DataRecord;

// Получаем переменную с определениями переменных модели
DataTable modelVariables = modelContext.getVariable(ModelContextConstants.V_MODEL_VARIABLES);
```

### Шаг 3: Создание нового определения переменной

```java
import com.tibbo.aggregate.common.datatable.TableFormat;
import com.tibbo.aggregate.common.datatable.SimpleDataTable;

// Создаем формат для новой переменной
// Формат: <name><S><D=Name>, <format><S><D=Format>, <readable><B><D=Readable>, <writable><B><D=Writable>, ...
TableFormat variableDefinitionFormat = modelVariables.getFormat();

// Создаем новую запись с определением переменной
DataRecord newVariableDef = modelVariables.addRecord();

// Устанавливаем поля определения переменной
newVariableDef.setValue("name", "myVariable");  // Имя переменной
newVariableDef.setValue("format", "<value><S><D=Value>");  // Формат переменной
newVariableDef.setValue("readable", true);  // Переменная доступна для чтения
newVariableDef.setValue("writable", true);  // Переменная доступна для записи
newVariableDef.setValue("description", "My Test Variable");  // Описание
newVariableDef.setValue("group", null);  // Группа (опционально)
newVariableDef.setValue("hidden", false);  // Скрыта ли переменная
```

### Шаг 4: Сохранение обновленных определений

```java
// Устанавливаем обновленную переменную обратно
modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
```

## Способ 2: Использование функции updateVariable

Если в контексте модели доступна функция `updateVariable`, можно использовать её:

```java
import com.tibbo.aggregate.common.datatable.SimpleDataTable;
import com.tibbo.aggregate.common.context.AbstractContext;

// Создаем параметры для функции updateVariable
// Формат параметров зависит от определения функции
TableFormat inputFormat = AbstractContext.FIFT_UPDATE_VARIABLE;
SimpleDataTable parameters = new SimpleDataTable(inputFormat);

// Добавляем определение переменной в параметры
DataRecord param = parameters.addRecord();
param.setValue("name", "myVariable");
param.setValue("format", "<value><S><D=Value>");
param.setValue("readable", true);
param.setValue("writable", true);
param.setValue("description", "My Test Variable");

// Вызываем функцию
try {
    DataTable result = modelContext.callFunction(AbstractContext.F_UPDATE_VARIABLE, parameters);
    System.out.println("✓ Переменная успешно создана");
} catch (ContextException e) {
    System.err.println("✗ Ошибка при создании переменной: " + e.getMessage());
}
```

## Полный пример

```java
package examples;

import com.tibbo.aggregate.common.Log;
import com.tibbo.aggregate.common.context.Context;
import com.tibbo.aggregate.common.context.ContextManager;
import com.tibbo.aggregate.common.context.ContextException;
import com.tibbo.aggregate.common.datatable.DataTable;
import com.tibbo.aggregate.common.datatable.DataRecord;
import com.tibbo.aggregate.common.server.ModelContextConstants;
import com.tibbo.aggregate.common.protocol.RemoteServer;
import com.tibbo.aggregate.common.protocol.RemoteServerController;

public class CreateVariableInModelExample {
    
    public static void main(String[] args) {
        Log.start();
        
        RemoteServerController controller = null;
        
        try {
            // Подключение к серверу
            RemoteServer server = new RemoteServer("localhost", 6460, "admin", "admin");
            controller = new RemoteServerController(server, true);
            controller.connect();
            controller.login();
            
            // Получение контекста модели
            ContextManager cm = controller.getContextManager();
            Context modelContext = cm.get("users.admin.models.myModel");
            
            if (modelContext == null) {
                System.err.println("✗ Контекст модели не найден");
                return;
            }
            
            System.out.println("✓ Контекст модели найден: " + modelContext.getPath());
            
            // Получение текущих определений переменных
            DataTable modelVariables = modelContext.getVariable(ModelContextConstants.V_MODEL_VARIABLES);
            System.out.println("✓ Получено определений переменных: " + modelVariables.getRecordCount());
            
            // Создание нового определения переменной
            DataRecord newVariableDef = modelVariables.addRecord();
            newVariableDef.setValue("name", "testVariable");
            newVariableDef.setValue("format", "<value><S><D=Value>");
            newVariableDef.setValue("readable", true);
            newVariableDef.setValue("writable", true);
            newVariableDef.setValue("description", "Test Variable for Model");
            newVariableDef.setValue("hidden", false);
            
            // Сохранение обновленных определений
            modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
            System.out.println("✓ Переменная 'testVariable' успешно создана в модели");
            
        } catch (ContextException e) {
            System.err.println("✗ Ошибка контекста: " + e.getMessage());
            e.printStackTrace();
        } catch (Exception e) {
            System.err.println("✗ Ошибка: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (controller != null && controller.isConnected()) {
                try {
                    controller.disconnect();
                } catch (Exception e) {
                    // Игнорируем ошибки при отключении
                }
            }
        }
    }
}
```

## Структура определения переменной в V_MODEL_VARIABLES

Определение переменной в `V_MODEL_VARIABLES` содержит следующие поля:

| Поле | Тип | Описание |
|------|-----|----------|
| `name` | String | Имя переменной (обязательно) |
| `format` | String | Формат таблицы переменной (обязательно) |
| `readable` | Boolean | Доступна ли переменная для чтения |
| `writable` | Boolean | Доступна ли переменная для записи |
| `description` | String | Описание переменной |
| `group` | String | Группа переменной (опционально) |
| `hidden` | Boolean | Скрыта ли переменная |
| `readPermissions` | String | Права на чтение (опционально) |
| `writePermissions` | String | Права на запись (опционально) |

## Формат переменной

Формат переменной задается строкой в специальном синтаксисе AggreGate:

```
<fieldName><fieldType><D=Description><H=Help>
```

Примеры:
- `"<value><S><D=Value>"` - строка с именем поля "value"
- `"<id><I><D=ID>, <name><S><D=Name>"` - таблица с двумя полями: id (Integer) и name (String)

## Важные замечания

1. **Проверка существования переменной:**
   ```java
   // Перед добавлением проверьте, не существует ли уже переменная с таким именем
   DataTable modelVariables = modelContext.getVariable(ModelContextConstants.V_MODEL_VARIABLES);
   DataRecord existing = modelVariables.select("name", "myVariable");
   if (existing != null) {
       System.out.println("⚠ Переменная 'myVariable' уже существует");
   }
   ```

2. **Обновление существующей переменной:**
   ```java
   // Для обновления найдите существующую запись и измените её
   DataRecord existing = modelVariables.select("name", "myVariable");
   if (existing != null) {
       existing.setValue("description", "Updated Description");
       modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
   }
   ```

3. **Удаление переменной:**
   ```java
   // Удалите запись из таблицы определений
   DataRecord toRemove = modelVariables.select("name", "myVariable");
   if (toRemove != null) {
       modelVariables.removeRecord(toRemove);
       modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
   }
   ```

## Обработка ошибок

```java
try {
    DataTable modelVariables = modelContext.getVariable(ModelContextConstants.V_MODEL_VARIABLES);
    // ... работа с переменными ...
    modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
} catch (ContextException e) {
    if (e.getMessage().contains("not available")) {
        System.err.println("✗ Переменная V_MODEL_VARIABLES недоступна");
        System.err.println("  Возможно, контекст не является моделью или не полностью инициализирован");
    } else {
        System.err.println("✗ Ошибка: " + e.getMessage());
    }
}
```

## Рекомендации

1. **Всегда проверяйте существование переменной** перед добавлением
2. **Используйте клонирование** для безопасного изменения:
   ```java
   DataTable modelVariables = modelContext.getVariableClone(ModelContextConstants.V_MODEL_VARIABLES);
   // ... изменения ...
   modelContext.setVariable(ModelContextConstants.V_MODEL_VARIABLES, modelVariables);
   ```
3. **Обрабатывайте ошибки** при работе с удаленными контекстами
4. **Логируйте операции** для отладки

## См. также

- `РЕШЕНИЕ_ПРОБЛЕМЫ_КОНТЕКСТА_МОДЕЛИ.md` - решение проблемы инициализации контекста модели
- `examples/ContextCreationExample.java` - пример создания контекстов
- `examples/ModelContextProtocolTest.java` - тесты работы с контекстом модели

